package com.github.sstone.amqp

import akka.actor.{Props, ActorRef}
import akka.event.LoggingReceive
import com.github.sstone.amqp.Amqp._
import com.rabbitmq.client.AMQP.BasicProperties
import com.rabbitmq.client.{Envelope, Channel, DefaultConsumer}

object RpcClient {

  case class Request(publish: List[Publish], numberOfResponses: Int = 1, updateEvery: Option[Int] = None)

  object Request {
    def apply(publish: Publish) = new Request(List(publish), 1)
  }

  case class Response(deliveries: List[Delivery])

  case class Status(correlationId: String, received: Int, total: Int)

  case class StatusRequest(correlationId: String)

  case class Undelivered(msg: ReturnedMessage)

  def props(channelParams: Option[ChannelParameters] = None): Props = Props(new RpcClient(channelParams))

  private[amqp] case class RpcResult(destination: ActorRef, expected: Int, updateEvery: Option[Int], deliveries: scala.collection.mutable.ListBuffer[Delivery])

}

class RpcClient(channelParams: Option[ChannelParameters] = None) extends ChannelOwner(channelParams = channelParams) {

  import RpcClient._

  var queue: String = ""
  var consumer: Option[DefaultConsumer] = None
  var counter: Int = 0
  var correlationMap = scala.collection.mutable.Map.empty[String, RpcResult]

  override def onChannel(channel: Channel, forwarder: ActorRef) {
    super.onChannel(channel, forwarder)
    // create a private, exclusive reply queue; its name will be randomly generated by the broker
    queue = declareQueue(channel, QueueParameters("", passive = false, exclusive = true)).getQueue
    log.debug(s"setting consumer on private queue $queue")
    consumer = Some(new DefaultConsumer(channel) {
      override def handleDelivery(consumerTag: String, envelope: Envelope, properties: BasicProperties, body: Array[Byte]) {
        self ! Delivery(consumerTag, envelope, properties, body)
      }
    })
    channel.basicConsume(queue, false, consumer.get)
    correlationMap.clear()
  }

  override def disconnected: Receive = LoggingReceive ({
    case request@Request(publish, numberOfResponses, updateEvery) => {
      log.warning(s"not connected, cannot send rpc request")
    }
  }: Receive) orElse super.disconnected

  override def connected(channel: Channel, forwarder: ActorRef): Receive = LoggingReceive({
    case Request(publish, numberOfResponses, updateEvery) => {
      counter = counter + 1
      log.debug(s"sending ${publish.size} messages, replyTo = $queue")
      publish.foreach(p => {
        val props = p.properties.getOrElse(new BasicProperties()).builder.correlationId(counter.toString).replyTo(queue).build()
        channel.basicPublish(p.exchange, p.key, p.mandatory, p.immediate, props, p.body)
      })
      if (numberOfResponses > 0) {
        correlationMap += (counter.toString -> RpcResult(sender, numberOfResponses, updateEvery, collection.mutable.ListBuffer.empty[Delivery]))
        if (updateEvery.isDefined){
          sender ! Status(counter.toString, 0, numberOfResponses)
        }
      }
    }
    case delivery@Delivery(consumerTag: String, envelope: Envelope, properties: BasicProperties, body: Array[Byte]) => {
      channel.basicAck(envelope.getDeliveryTag, false)
      correlationMap.get(properties.getCorrelationId) match {
        case Some(results) => {
          results.deliveries += delivery
          if (results.deliveries.length == results.expected) {
            results.destination ! Response(results.deliveries.toList)
            correlationMap -= properties.getCorrelationId
          }else {
            results.updateEvery
            .filter(f => results.deliveries.length % f == 0)
            .foreach { e =>
              results.destination ! Status(properties.getCorrelationId, results.deliveries.length, results.expected)
            }
          }
        }
        case None => log.warning("unexpected message with correlation id " + properties.getCorrelationId)
      }
    }
    case StatusRequest(correlationId) => {
      sender ! (correlationMap.get(correlationId) match {
        case Some(results) =>
          Status(correlationId, results.deliveries.length, results.expected)
        case None =>
          Status(correlationId, 0, 0)
      })
    }
    case msg@ReturnedMessage(replyCode, replyText, exchange, routingKey, properties, body) => {
      correlationMap.get(properties.getCorrelationId) match {
        case Some(results) => {
          results.destination ! RpcClient.Undelivered(msg)
          correlationMap -= properties.getCorrelationId
        }
        case None => log.warning("unexpected returned message with correlation id " + properties.getCorrelationId)
      }
    }
  }: Receive) orElse super.connected(channel, forwarder)
}
